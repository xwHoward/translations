# 模块

*原文链接[http://exploringjs.com/es6/ch_modules.html#sec_overview-modules](http://exploringjs.com/es6/ch_modules.html#sec_overview-modules)*

## 1 概述

JavaScript的模块已经存在很长一段时间了，然而它们是通过库实现的，而不是内置于语言中。ES6是JavaScript第一次将模块内置。

ES6模块存储在文件中。每个文件只有一个模块，每个模块只有一个文件。有两种从模块导出东西的方法，这两种方法可以[混合使用](http://exploringjs.com/es6/ch_modules.html#sec_mixing-named-and-default-exports)，但最好还是分别使用它们。

### 1.1 多命名导出

可以导出多个命名：

```js
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
```

你还可以导入完整的模块：

```js
//------ main.js ------
import * as lib from 'lib';
console.log(lib.square(11)); // 121
console.log(lib.diag(4, 3)); // 5
```

### 1.2 单个默认导出

可以有一个默认的导出。例如，一个函数：

```js
//------ myFunc.js ------
export default function () { ··· } // 没有分号！

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();
```

或者一个类：

```js
//------ MyClass.js ------
export default class { ··· } // 没有分号！

//------ main2.js ------
import MyClass from 'MyClass';
const inst = new MyClass();
```

请注意，如果你默认导出函数或类（它们是匿名声明），则最后没有分号。

### 1.3 浏览器：脚本 v.s. 模块

||脚本|模块|
|-|-|-|
|HTML元素|```<script>```|```<script type="module">```|
|默认模式|非严格模式|严格模式|
|顶级变量是|全局|模块局部变量|
|顶级```this```值|```window```|```undefined```|
|执行|同步|异步|
|导入声明（import语句）|没有|有|
|程序化导入（基于Promise的API）|是|是|
|文件扩展名|.js|.js|

## 2 JavaScript中的模块

即使JavaScript从未内置模块，社区也融合了一种简单的模块形式，这在ES5及更早版本中通过库来支持。ES6也采用了这种风格：

- 每个模块都是一段代码，一旦加载就执行。
- 在这段代码中，可能有声明（变量声明，函数声明等）。
    - 默认情况下，这些声明作用于模块局部。
    - 你可以将其中的一些标记为导出项，然后其他模块可以引入它们。
- 模块可以从其他模块引入代码。它通过模块说明符或者字符串指向那些模块：
    - 相对路径（'../model/user'）：这些路径相对于导入模块的位置进行解析。文件扩展名.js通常可以省略。
    - 绝对路径（'/lib/js/helpers'）：直接指向要导入的模块的文件。
    - Names（'util'）：必须配置哪些模块名称。
- 模块是单例的。即使多次导入模块，也只存在一个“实例”。

模块的这种形式避免了全局变量，唯一的全局变量是模块描述符。

### 2.1 ECMAScript 5模块系统

神奇的是ES5模块系统如何在没有语言明确支持的情况下工作。两个最重要的（不幸的是他们互不兼容）标准是：

- CommonJS模块：该标准的主要实现在Node.js（Node.js模块具有超出CommonJS的几个功能）。特点：
    - 语法紧凑
    - 专为同步加载和服务端设计
- 异步模块定义（AMD）：该标准最受欢迎的实现是RequireJS。特点：
    - 稍微复杂的语法，使AMD无需eval()（或编译步骤）就能实现功能
    - 专为异步加载和浏览器端设计

以上只是ES5模块系统的简化说明。如果你想要更深入的材料，请查看Addy Osmani的["Writing Modular JavaScript With AMD, CommonJS & ES Harmony"](http://addyosmani.com/writing-modular-js/)。

### 2.2 ECMAScript 6模块

ECMAScript 6模块的目标是创建一种能让CommonJS和AMD的用户都满意的形式：

- 与CommonJS类似，它们具有紧凑的语法，对单个导出的偏好以及对循环依赖的支持。
- 与AMD类似，它们直接支持了异步加载和可配置化的模块加载。

ES6语言内嵌的模块系统超越了CommonJS和AMD（后面会详细解释）：

- 他的语法比CommonJS更紧凑。
- 可以对其结构进行静态分析（静态检查，优化等）。
- 他对循环依赖的支持比CommonJS更好。

ES6模块标准有两部分：

- 声明式语法（用于导入和导出）
- 程序化加载的API：可配置模块的加载方式以及条件式加载模块

## 3 ES6模块基础

有两种导出方式：命名式导出（每个模块可以导出若干个）和默认导出（每个模块只导出一个）。后面会讲到，可以同时使用这两种形式，但通常最好分开使用。

### 3.1 命名式导出（每个模块可以导出若干个）

模块可以通过在声明前加上关键字```export```来导出多个内容。这些导出项以其名称区分，称为*具名导出(Named Exports)*。

```js
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
```

还有其他方法可以指定具名导出（稍后再说明），但是我发现这个方法非常方便：只需编写代码，不需要关心外部环境，然后使用关键字对要导出的所有内容进行标记。
你也可以通过属性标记来导入整个模块并引用其具名导出项：

```js
//------ main.js ------
import * as lib from 'lib';
console.log(lib.square(11)); // 121
console.log(lib.diag(4, 3)); // 5
```

CommonJS语法中的相同代码：有一段时间我尝试了几个更好的策略，以减少在Node.js中导出模块时的冗余。现在我更喜欢以下简单但稍微冗长的风格，让人联想到[显式的模块模式(revealing module pattern)](http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/)：

```js
//------ lib.js ------
var sqrt = Math.sqrt;
function square(x) {
    return x * x;
}
function diag(x, y) {
    return sqrt(square(x) + square(y));
}
module.exports = {
    sqrt: sqrt,
    square: square,
    diag: diag,
};

//------ main.js ------
var square = require('lib').square;
var diag = require('lib').diag;
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
```

### 3.2 默认导出（每个模块仅导出一个）

仅导出单个值的模块在Node.js社区中非常受欢迎。但是，它们在前端开发中也很常见，因为通常需要为数据模型和组件提供类，而每个类会由一个模块来提供。ES6模块可以选择默认导出项，和主要的导出项，而默认导出项能够轻松被引入。
以下的ECMAScript 6模块“是”一个函数：

```js
//------ myFunc.js ------
export default function () {} // no semicolon!

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();
```

默认导出项为一个类的ECMAScript 6模块如下所示：

```js
//------ MyClass.js ------
export default class {} // 没有分号！

//------ main2.js ------
import MyClass from 'MyClass';
const inst = new MyClass();
```

默认导出有两种形式：

1. 标签声明
2. 直接输出默认值

#### 3.2.1 默认导出形式1：标签声明(labeling declarations)

你可以使用关键字```export default```作为任何函数声明（或生成函数声明）或类声明的前缀，使其成为默认导出：

```js
export default function foo() {} // 没有分号！
export default class Bar {} // 没有分号！
```

在这种情况下也可以省略名称，这会使得默认导出只有JavaScript匿名函数声明和匿名类声明：

```js
export default function () {} // 没有分号!
export default class {} // 没有分号!
```

##### 3.2.1.1 为什么是匿名函数声明而不是匿名函数表达式？

当你查看上面两行代码时，你希望默认导出的操作数是表达式，但它们只能是声明，原因是一致性：操作数可以是命名的声明，它们的匿名形式被解析为表达式会令人困惑（甚至比引入新类型的声明更容易令人困惑）(They are only declarations for reasons of consistency: operands can be named declarations, interpreting their anonymous versions as expressions would be confusing (even more so than introducing new kinds of declarations))。

如果要将操作数解释为表达式，则需要使用括号：

```js
export default (function () {});
export default (class {});
```

#### 3.2.2 默认导出形式2：直接导出默认值

这些值通过表达式生成：

```js
export default 'abc';
export default foo();
export default /^xyz$/;
export default 5 * 7;
export default { no: false, yes: true };
```

这些默认导出中的每一个具有以下结构。

```js
export default «expression»;
```

这相当于：

```js
const __default__ = «expression»;
export { __default__ as default }; // (A)
```

行A中的声明是一个导出语句（稍后部分将对此进行解释）。

##### 3.2.2.1 为什么要使用两种默认的导出形式？

引入第二种默认导出形式是因为如果变量声明声明了多个变量，则变量声明不能被正确地转换为默认导出：

```js
export default const foo = 1, bar = 2, baz = 3; // not legal JavaScript!
```

三个变量中的哪一个foo，bar并且baz会默认导出？

#### 16.3.3 进出口必须在顶层

如稍后会详细解释，ES6模块的结构是静态的，不能有条件地导入或导出，这样做有很多好处。
这种语法上的强制限制，只允许在模块的顶层进行导入和导出：

```js
if (Math.random()) {
    import 'foo'; // SyntaxError
}

// 即使是将 `import` 和 `export`
// 放在简单的代码块里也不行：
{
    import 'foo'; // SyntaxError
}
```

#### 16.3.4 导入被提升

导入模块会被提升（在内部被移动到当前作用域的开头）。因此，在模块中哪里声明它们并不重要。以下代码没有任何问题：

```js
foo();
import { foo } from 'my_module';
```

#### 16.3.5 导入是导出的只读视图

ES6模块的导入项是导出实例的只读视图。这意味着与模块体内声明的变量的关联持续存在，如下面的代码所示。

```js
//------ lib.js ------
export let counter = 3;
export function incCounter() {
    counter++;
}

//------ main.js ------
import { counter, incCounter } from './lib';

// The imported value `counter` is live
console.log(counter); // 3
incCounter();
console.log(counter); // 4
```

底层实现将在后面的章节中介绍。
以视图的形式引入具有以下优点：

- 它们能够实现循环依赖，即使是不合格(unqualified)的导入（如下一节所述）。
- 合格和不合格的导入作用相同（两者均为双向）。
- 你可以将代码分割成多个模块却不影响功能（只要你不尝试更改导入的值）。

#### 16.3.6 支持循环依赖

如果A（间接/传递性地）导入了B而B又导入了A，那么两个模块A和B是相互依赖的。应该尽可能地避免循环依赖，它们导致A和B紧密耦合 - 它们只能一起使用和迭代。
那为什么还要支持循环依赖呢？因为你不能完全避免这种情况的发生，这就是为什么支持循环依赖是一个重要的特性。
让我们看看CommonJS和ECMAScript 6如何处理循环依赖。

##### 16.3.6.1 CommonJS的循环依赖

以下CommonJS代码正确地处理两个模块，a和b循环依赖于彼此。

```js
//------ a.js ------
var b = require('b');
function foo() {
    b.bar();
}
exports.foo = foo;

//------ b.js ------
var a = require('a'); // (i)
function bar() {
    if (Math.random()) {
        a.foo(); // (ii)
    }
}
exports.bar = bar;
```

如果a首先导入模块，则在第i行中，在导出导入对象之前，module b将获取a导出对象。因此，b无法访问a.foo其顶层，但一旦执行a完成，该属性就存在。如果bar()之后被调用，那么在第二行中的方法调用工作。

作为一般规则，请记住，使用循环依赖关系，你无法访问模块正文中的导入。这是现象所固有的，ECMAScript 6模块不会改变。

CommonJS方法的局限性是：

Node.js风格的单值导出不起作用。在那里，你导出单个值而不是对象：
  module.exports = function () { ··· };
如果模块a做了，那么模块b的变量a一旦作出分配就不会被更新。它将继续引用原始的出口对象。

你不能直接使用命名导出。也就是说，模块b不能foo像这样导入：
  var foo = require('a').foo;
foo只会是undefined。换句话说，你别无选择，只能foo通过参考a.foo。

这些限制意味着出口商和进口商都必须意识到循环依赖并明确支持它们。

16.3.6.2循环依赖于ECMAScript 6 

ES6模块自动支持循环依赖。也就是说，它们没有上一节中提到的CommonJS模块的两个限制：默认导出工作，以及不合格的命名导入（下面的示例中的行i和iii）。因此，你可以实现循环依赖的模块，如下所示。

//------ a.js ------
import {bar} from 'b'; // (i)
export function foo() {
    bar(); // (ii)
}

//------ b.js ------
import {foo} from 'a'; // (iii)
export function bar() {
    if (Math.random()) {
        foo(); // (iv)
    }
}
此代码可以正常工作，因为如上一节所述，导入是导出的视图。这意味着即使不合格进口（如第二bar行和foo第四行）也是引用原始数据的指令。因此，面对循环依赖关系，无论你是通过不合格的导入还是通过其模块访问命名的导出都不重要：在任何一种情况下都涉及间接性，并且始终可以使用。